#include <stdio.h>
#include <stdlib.h>
//#include "userled.h"

void userLED(int LED_number, int on_off)
{
	FILE* fd;
	if (LED_number > 3 && LED_number < 0)
	{
		printf("Invalid led number");
		exit(-1);
	}

	if (on_off != 0 && on_off != 1)
	{
		printf("Input should be either 0 or 1");
	}
	switch(LED_number)
	{
		case 1:
			fd = fopen("/sys/devices/platform/leds/leds/beaglebone:green:usr0/brightness", "w");
			fprintf(fd,"%i",on_off);
			break;
		case 2:
			fd = fopen("/sys/devices/platform/leds/leds/beaglebone:green:usr1/brightness", "w");
			fprintf(fd,"%i",on_off);
			break;
		case 3:
			fd = fopen("/sys/devices/platform/leds/leds/beaglebone:green:usr2/brightness", "w");
			fprintf(fd,"%i",on_off);
			break;
	}
	fclose(fd);
}
#include "startup.h"

bool startup()
{
	// temperatture intilization
	int fd = temp_init();
	if (fd < 0)
	{
		printf("Temperature sensor intialization failed.\n");
		return false;
	}
	float value = read_temp_reg(fd,Celsius);
	if (value < -40 && value > 128)
	{
		printf("Temp out of range.\n");
		return false;
	}
	
	// Light sensor task intialization
	fd = light_sensor_setup();
	if (fd < 0)
	{
		printf("Light sensor intialization failed.\n");
		return false;
	}
	float lux = get_lux_value(fd);
	if (lux < -100 && lux > 1500)
	{
		printf("Lux value out of range.\n");
		return false;
	}

	// Thread creation check
	/*if (!temp_task_life)
	{
		printf("Temperature thread creation failed. \n");
		return false;
	}
	if (!light_task_life)
	{
		printf("Light thread creation failed. \n");
		return false;
	}
	if (!logger_task_life)
	{
		printf("Logger thread creation failed. \n");
		return false;
	}
	if (!socket_task_life)
	{
		printf("Socket thread creation failed. \n");
		return false;
	}*/

	return true;
	 
}

#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <fcntl.h> 
#include <sys/stat.h>
#include <mqueue.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <stdbool.h>

#include "light_task.h"
#include "temp_task.h"
#include "logger_task.h"
#include "socket_task.h"

#define queue_name 		"/my_queue"
#define queue_size		8

#define SERVER_QUEUE_NAME   "/my_msg_queue_server"
#define QUEUE_PERMISSIONS 0666
#define MAX_MESSAGES 10
#define MAX_MSG_SIZE 256
#define MSG_BUFFER_SIZE MAX_MSG_SIZE + 10

int count = 0;

pthread_t light_thread;
pthread_t temp_thread;
pthread_t logger_thread;
pthread_t socket_thread;

int light_task_life = 0;
int temp_task_life = 0;
int logger_task_life = 0;
int socket_task_life = 0;

void * light_thread_func()
{
	int fd = light_sensor_setup();
	float lux;

	mqd_t logger;   // queue descriptors   
   	struct mq_attr attr;

	attr.mq_maxmsg = MAX_MESSAGES;
    	attr.mq_msgsize = sizeof(temp_data);
	temp_data temp;
	int command;
	int sock;

	while(1)
	{
		int sock;
	struct sockaddr_in server;
	char buff[1024];
	struct hostent *hp;
	
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock < 0)
	{
		perror("socket failed");
		exit(1);
	}
	server.sin_family = AF_INET;
	hp = gethostbyname("localhost");
	if(hp == 0)
	{
		perror("gethost failed");
		exit(1);
	}
	memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
	server.sin_port = htons(6006);
	
	if(connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
	{
		perror("connection failes");
		exit(1);
	}

	int command = Light;
	
	
	if(send(sock, (void*)&command, sizeof(command), 0) < 0)
	{
		perror("Send failed");
		exit(1);
	}
	close(sock);
		lux = get_lux_value(fd);
		printf("LUX: %f", lux);
		temp_data temp;
	
		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        	printf("ERROR opening message queue\n");
	
		temp.tempval = lux;
		temp.t = 8;
		temp.log_source_id = Light_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");

		//loggerFN();
		sleep(1);
	}
	command = Dead;
	if(send(sock, (void*)&command, sizeof(command), 0) < 0)
	{
		perror("Send failed");
		printf("Some thread dead, Terminating process\n");

		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        	printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 4;
		temp.log_source_id = Main_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
		exit(1);
	}
}

void * temp_thread_func()
{
	int fd;
	float value;
	fd = temp_init();
	mqd_t logger;   // queue descriptors   
   	struct mq_attr attr;
	
	float* buff;
	char * finalptr;
	temp_data temp;
	int command;
	int sock;
	
    	attr.mq_maxmsg = MAX_MESSAGES;
    	attr.mq_msgsize = sizeof(temp_data);

	while(1)
	{
	struct sockaddr_in check_server;
	char buff[1024];
	struct hostent *hp;
	
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock < 0)
	{
		perror("socket failed");
		exit(1);
	}
	check_server.sin_family = AF_INET;
	hp = gethostbyname("localhost");
	if(hp == 0)
	{
		perror("gethost failed");
		exit(1);
	}
	memcpy(&check_server.sin_addr, hp->h_addr, hp->h_length);
	check_server.sin_port = htons(6006);
	
	if(connect(sock, (struct sockaddr *)&check_server, sizeof(check_server)) < 0)
	{
		perror("connection failes");
		exit(1);
	}

	command = Light;
	
	
	if(send(sock, (void*)&command, sizeof(command), 0) < 0)
	{
		perror("Send failed");
		exit(1);
	}
	close(sock);		
		
		value = read_temp_reg(fd,Kelvin);
		printf("TEMP: %f", value);
		
		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        	printf("ERROR opening message queue\n");
	
		temp.tempval = value;
		temp.t = 7;
		temp.log_source_id = Temp_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
		sleep(1);

		//mq_unlink(SERVER_QUEUE_NAME);

	
	}
	command = Dead;
	if(send(sock, (void*)&command, sizeof(command), 0) < 0)
	{
		perror("Send failed");
		printf("Some thread dead, Terminating process\n");

		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        	printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 4;
		temp.log_source_id = Main_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
		exit(1);
	}
}

void * logger_thread_func()
{	
	loggerFN();
	mqd_t logger;   // queue descriptors   
   	struct mq_attr attr;
	
	float* buff;
	char * finalptr;
	temp_data temp;
	int command;
	int sock;
	
    	attr.mq_maxmsg = MAX_MESSAGES;
    	attr.mq_msgsize = sizeof(temp_data);
	while(1)
	{
	struct sockaddr_in check_server;
	char buff[1024];
	struct hostent *hp;
	
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock < 0)
	{
		perror("socket failed");
		exit(1);
	}
	check_server.sin_family = AF_INET;
	hp = gethostbyname("localhost");
	if(hp == 0)
	{
		perror("gethost failed");
		exit(1);
	}
	memcpy(&check_server.sin_addr, hp->h_addr, hp->h_length);
	check_server.sin_port = htons(6006);
	
	if(connect(sock, (struct sockaddr *)&check_server, sizeof(check_server)) < 0)
	{
		perror("connection failes");
		exit(1);
	}

	command = Logger;
	
	
	if(send(sock, (void*)&command, sizeof(command), 0) < 0)
	{
		perror("Send failed");
		exit(1);
	}
	close(sock);
	}
	command = Dead;
	if(send(sock, (void*)&command, sizeof(command), 0) < 0)
	{
		perror("Send failed");
		printf("Some thread dead, Terminating process\n");

		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        	printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 4;
		temp.log_source_id = Main_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
		exit(1);
	}
}

void * socket_thread_func()
{
	socket_server();
}

bool startup()
{
	int fd = temp_init();
	if (fd < 0)
	{
		printf("Temperature sensor intialization failed.\n");
		return false;
	}
	float value = read_temp_reg(fd,Celsius);
	if (value < -40 && value > 128)
	{
		printf("Temp out of range.\n");
		return false;
	}
	
	fd = light_sensor_setup();
	if (fd < 0)
	{
		printf("Light sensor intialization failed.\n");
		return false;
	}
	float lux = get_lux_value(fd);
	if (lux < -100 && lux > 1500)
	{
		printf("Lux value out of range.\n");
		return false;
	}
	if (!temp_task_life)
	{
		printf("Temperature thread creation failed. \n");
		return false;
	}
	if (!light_task_life)
	{
		printf("Light thread creation failed. \n");
		return false;
	}
	if (!logger_task_life)
	{
		printf("Logger thread creation failed. \n");
		return false;
	}
	if (!socket_task_life)
	{
		printf("Socket thread creation failed. \n");
		return false;
	}
	printf("Startup tests successful, proceeding with actual functionalities\n");
	return true;

}

void check_status()
{
	int sock;
	struct sockaddr_in check_server;
	int mysock;
	char buff[1024];
	int rval;
	int flag = 0;
	//create socket
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock < 0)
	{
		perror("Failed to create a socket");
		exit(1);
	}
	
	check_server.sin_family = AF_INET;
	check_server.sin_addr.s_addr = INADDR_ANY;
	check_server.sin_port = htons(6006);
	
	//bind
	if(bind(sock, (struct sockaddr *)&check_server, sizeof(check_server)) < 0)
	{
		perror("Didn't bind");
		exit(1);
	}

	//Listen
	if(listen(sock, 5) < 0)
	{
		perror("Listening error");
		exit(1);
	}

	//Accept
	while(1)
	{
	mysock = accept(sock, (struct sockaddr *)0, 0);
	if(mysock == -1)
	{
		perror("Accept failed");
		exit(1);
	}
	int incoming;
	
	int data_in = read(mysock,&incoming,sizeof(incoming));
     
	if (data_in < 0)
	{ 
		perror("Error reading");
		exit(1);
	}

	if(incoming  == 2)
	{
		printf("Temp task Dead\n");
		break;
	}

	}
	exit(1);
}



void main()
{
	int light_thread_check;
	int temp_thread_check;
	int logger_thread_check;
	int socket_thread_check;
	int d;
	printf("Getting started with things, Main task initiated\n");

	mqd_t logger;   // queue descriptors   
   	struct mq_attr attr;
	
	float* buff;
	char * finalptr;
	temp_data temp;
	
    	attr.mq_maxmsg = MAX_MESSAGES;
    	attr.mq_msgsize = sizeof(temp_data);

	logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
	if (logger < 0) 
        printf("ERROR opening message queue\n");
	
	temp.tempval = 0;
	temp.t = 0;
	temp.log_source_id = Main_task;
	char* buffptr = (char*)(&temp);
	
	if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
	printf("ERROR mq_send\n");
	
	printf("Initializing creation of thread processes\n");

	light_thread_check = pthread_create(&light_thread, NULL, light_thread_func, NULL);
	if(light_thread_check)
	{
		perror("Error creating light thread");
		exit(-1);
	}
	else
	{
		light_task_life = 1;
		printf("Light thread created\n");
		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        		printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 1;
		temp.log_source_id = Main_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
	}

	temp_thread_check = pthread_create(&temp_thread, NULL, temp_thread_func, NULL);
	if(temp_thread_check)
	{
		perror("Error creating temp thread");
		exit(-1);
	}
	else
	{
		printf("Temp thread created\n");
		temp_task_life = 1;
		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        		printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 2;
		temp.log_source_id = Main_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
	}

	logger_thread_check = pthread_create(&logger_thread, NULL, logger_thread_func, NULL);
	if(logger_thread_check)
	{
		perror("Error creating logger thread");
		exit(-1);
	}
	else
	{
		printf("Logger thread created\n");
		logger_task_life = 1;
		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        		printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 3;
		temp.log_source_id = Main_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
	}
	
	socket_thread_check = pthread_create(&socket_thread, NULL, socket_thread_func, NULL);
	if(socket_thread_check)
	{
		perror("Error creating socket thread");
		exit(-1);
	}
	else
	{
		printf("Socket thread created\n");
		socket_task_life = 1;
		logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        		printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 5;
		temp.log_source_id = Main_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");
	}

	if(!startup())
		exit(-1);

	check_status();	

	pthread_join(light_thread, NULL);
	pthread_join(temp_thread, NULL);
	pthread_join(logger_thread, NULL);
	pthread_join(socket_thread, NULL);
}
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<stdint.h>
#include<linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <math.h>
#include<complex.h>
#include<stdint.h>

/*Change to 1 to check library functions from main.c*/
#define CHECK_LIBRARY      0x00

/*Address on I2C device*/
#define TMP102_ADDRESS    0x48

/*Address to pointer register*/
#define POINTER_ADDRESS    0x00
/*Address of different registers
 * Or it with pointer registers
 */
#define TEMPREG_ADDRESS    0x00
#define    CONFREG_ADDRESS    0x01
#define    TLOWREG_ADDRESS    0x02
#define    THIGHREG_ADDRESS    0x03

/*Default configuration on register*/
#define    CONFIG_DEFAULT    0xA060

/*Different modes in config_register
 * Or these with CONFIG_DEFAULT
 */
#define SHUTDOWN_MODE    0x0001
#define    THERMOSTAT_MODE    0x0002
#define POLARITY        0x0004
#define ONESHOT_MODE    0x0080
#define    EXTND_MODE        0x1000

/*Different modes for temperature conversions
 */
#define CELSIUS            0x00
#define FAHRENHEIT        0x01
#define    KELVIN            0x02

/*Enum of returns*/
enum{
    SUCCESS = 0,
    FAIL = -1
} returns;


/**********************************************************************
*@Filename:tmp102.c
*
*@Description:This is a library for TMP102 sensor
*@Author:Sai Raghavendra Sankrantipati
*@Date:11/5/2017
*@compiler:arm-linux-gnueabihf-gcc
*@Usage : Connect TMP102 to I2C 2 and use any of the library function to read and write registers
 **********************************************************************/

/*Initialse sensor by opening dev/i2c-2*/
int tmp102_init(int bus){
    int file;
    char filename[20];

    snprintf(filename, 19, "/dev/i2c-%d", bus);
    file = open(filename, O_RDWR);
    if (file < 0) {
        perror("Unable to open file\n");
        return FAIL;
    }
    int addr = TMP102_ADDRESS; /* The I2C address */

    if (ioctl(file, I2C_SLAVE, addr) < 0) {
        perror("Unable to ioctl\n");
        return FAIL;
    }
    return file;
}



/*Write to pointer register
 * An call to registers are made
 * only through pointer register
 */
int write_pointerreg(int fd, uint8_t reg){
    uint8_t buf = POINTER_ADDRESS | reg;
    if( write(fd, &buf, 1) != 1){
        perror("Unable to write\n");
        return FAIL;
    }
    return SUCCESS;

}

/*Write to Config register
 *  Pass CONFIG_DEFAULT for default configuration and
 *  SHUTDOWN_MODE    0x0001
 *    THERMOSTAT_MODE    0x0002
 *     POLARITY        0x0004
 *     ONESHOT_MODE    0x0080
 *    EXTND_MODE        0x1000
 *    for different mode options
 */

uint16_t write_configreg(int fd, uint16_t config_val){
    write_pointerreg(fd, CONFREG_ADDRESS);

    uint8_t temp1 = (CONFIG_DEFAULT|config_val)>>8;
    uint8_t temp2 = (CONFIG_DEFAULT|config_val);
    uint8_t buf[3] = { POINTER_ADDRESS | CONFREG_ADDRESS, temp2, temp1};

    if( write(fd, buf, 3) != 3){
        perror("Unable to write\n");
        return FAIL;
    }

    return config_val;
}


/* Read config register. Use it for debugging*/
uint16_t read_configreg(int fd){

    write_pointerreg(fd, CONFREG_ADDRESS);
    uint16_t buf;
    if( read(fd, &buf, 2) != 2){
        perror("Unable to read\n");
        return FAIL;
    }
    printf("Config Register (TMP 102) : %d\n", buf);
    return buf;
}

/*This function fetches the 12/13 bit temperature from tmp102*/
int read_tempreg(int fd, uint16_t *res){
    write_pointerreg(fd, TEMPREG_ADDRESS);
    uint8_t buf[2];
    if( read(fd, buf, 2) != 2){
        perror("Unable to read\n");
        return FAIL;
    }

    int temp = (uint16_t)buf[0]<<4 | buf[0]>>4;
    *res = temp;
    return temp;
}


/* This converts temperature in different types and prints on consle
 * Pass 12/13bit adc register value and mode (12 or 13 bit mode)
 * 0.0625 is the resoluion of sensor. So multiply it to get celsius and
 * convert accordingly
 */
int convert_temp(int temp, int mode){

    if(mode == EXTND_MODE){

        if((temp & 0xA00) == 0){
            float celsius = temp * 0.0625;
            float fahrenheit = (1.8 * celsius) +32;
            float kelvin = celsius + 273.15;

            printf("Temperature in Celsius: %f  Fahrenheit:  %f Kelvin: %f\n", celsius, fahrenheit, kelvin);
            return SUCCESS;
        } else {
            temp = temp ^ 0xFFFF;
            float celsius = temp * (-0.0625);
            float fahrenheit = (1.8 * celsius) +32;
            float kelvin = celsius + 273.15;

            printf("Temperature in Celsius: %f  Fahrenheit:  %f Kelvin: %f\n", celsius, fahrenheit, kelvin);
            return SUCCESS;
        }
    } else if(mode == CONFIG_DEFAULT){
        if((temp & 0x800) == 0){
            float celsius = temp * 0.0625;
            float fahrenheit = (1.8 * celsius) +32;
            float kelvin = celsius + 273.15;

            printf("Temperature in Celsius: %f  Fahrenheit:  %f Kelvin: %f\n", celsius, fahrenheit, kelvin);
            return SUCCESS;
        } else {
            temp = temp ^ 0xFFFF;
            float celsius = temp * (-0.0625);
            float fahrenheit = (1.8 * celsius) +32;
            float kelvin = celsius + 273.15;

            printf("Temperature in Celsius: %f  Fahrenheit:  %f Kelvin: %f\n", celsius, fahrenheit, kelvin);
            return SUCCESS;
        }
    }
    return FAIL;
}

/*This calibrates temperature and returns in mode it's asked
 * Mode can be celsius or fahrenheit or kelvin
 * It returns a float
 */
float callibrate_temp(int temp, uint8_t mode){

    float celsius = temp * 0.0625;

    if(mode == CELSIUS)
        return celsius;
    else if(mode == FAHRENHEIT)
        return (1.8 * celsius) + 32;
    else if(mode == KELVIN)
        return celsius + 273.15;

    return FAIL;

}

/* This puts sensor in shutdown mode*/
int shutdown_mode(int fd, int mode){
    return write_configreg(fd, mode);
}

int change_resolution(int fd, int mode){
    return write_configreg(fd, mode);
}

/*It prints temperature*/
int print_temperature(int fd, int mode){
    if( write_configreg(fd, mode) == FAIL)
        return FAIL;
    uint16_t *temp = malloc(sizeof(uint16_t));

    read_tempreg(fd, temp);
    convert_temp(*temp, mode);
    return *temp;
}

/*Closes file descriptor opened in sensor_init*/
int close_tmp102(int fd){
    close(fd);
    return 1;
}


/* A function that calls all the registers and does reads and writes*/
int rw_allregs_tmp102(int fd){
    int status;
    uint16_t *res;
    res = malloc(sizeof(uint16_t));
    status = write_configreg(fd, CONFIG_DEFAULT);
    if( status ==  FAIL )
        return FAIL;
    status = read_configreg(fd);
    if( status ==  FAIL )
        return FAIL;
    status = read_tempreg(fd, res);
    if( status ==  FAIL )
        return FAIL    ;
    return SUCCESS;
}

void main()
{
	//while(1)
{
    int fd = tmp102_init(2);
    uint16_t v1 = write_configreg(fd, 0XE0);
    uint16_t v2 = read_configreg(fd);
    printf("Write %i\n",v1);
    printf("Read %i\n",v2);
	}
}
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <mqueue.h>
#include <errno.h>

enum{
Celsius,
Kelvin,
Fahrenheit
}Temp_unit;

enum{
	Success,
	Fail
}return_value;

#define Addr_temp_reg    0x00
#define Addr_config_reg  0x01
#define Addr_tlow_reg    0x02
#define Addr_thigh_reg 0x03

#define SERVER_QUEUE_NAME   "/my_msg_queue_server"
#define QUEUE_PERMISSIONS 0666
#define MAX_MESSAGES 10
#define MAX_MSG_SIZE 256
#define MSG_BUFFER_SIZE MAX_MSG_SIZE + 10

void write_pointer_reg(int fd, uint8_t reg);

uint16_t read_tlow_reg(int fd);

uint16_t read_thigh_reg(int fd);

float read_temp_reg(int fd, int unit);

int write_config_reg(int fd, uint16_t reg);

uint8_t read_config_reg(int fd);

int temp_init();
#include "temp_task.h"

void write_pointer_reg(int fd, uint8_t reg)
{
	int ret = write(fd, &reg, sizeof(reg));
	if (ret < 0)
	{
		perror("Write to pointer reg failed");
	}	
}

uint16_t read_tlow_reg(int fd)
{
	uint16_t tlow_value;
	uint8_t buff[1] = {0};
	
	write_pointer_reg(fd, Addr_tlow_reg);
	int ret =  read(fd,buff,sizeof(buff));
	if (ret < 0)
		perror("Read tlow reg failed");
	
	//shift?  tlow_value = 
	return tlow_value;
}

uint16_t read_thigh_reg(int fd)
{
	uint16_t thigh_value;
	uint8_t buff[1] = {0};
	write_pointer_reg(fd, Addr_thigh_reg);
	int ret =  read(fd,buff,sizeof(buff));
	if (ret < 0)
		perror("Read thigh reg failed");
	
	//shift?  thigh_value = 
	return thigh_value;
}

float read_temp_reg(int fd, int unit)
{
	
	int temp;
	float final_temp;
  	uint8_t msbval, lsbval;
	uint8_t buff[2];
	write_pointer_reg(fd, Addr_temp_reg);
	int ret = read(fd, &buff, sizeof(buff));
	if (ret != 2)
		perror("Read temp reg failed");
	
	//buff = buff>>4;
	msbval = buff[0];
	lsbval = buff[1];
	int msb = 80;
	int msb_bit = 0;
	/*if (msb & buff)
		msb_bit = 1;
	else msb_bit = 0;*/
	
	temp = ((msbval << 8) | lsbval) >> 4;
	printf("%d\n", temp);
	
	if (!msb_bit)
	{	final_temp = temp*0.0625;
		if (unit == Celsius)
		{
			return final_temp;
		}
		else if (unit == Kelvin)
		{
			final_temp = final_temp + 273.5;
			return final_temp;
		}
		else if (unit == Fahrenheit)
		{
			final_temp = (final_temp*1.8);
			final_temp = final_temp + 32;
			return final_temp;
		}
		else 
		{
			printf("Invalid unit of temperature");
			return Fail;
		}
	}
	else 
	{
		
		if (unit == Celsius)
		{
			return temp;
		}
		else if (unit == Kelvin)
		{
			temp = temp + 273.5;
			return temp;
		}
		else if (unit == Fahrenheit)
		{
			temp = (temp*1.8);
			temp = temp + 32;
			return temp;
		}
		else 
		{
			printf("Invalid unit of temperature");
			return Fail;
		}
	}
	


}


int write_config_reg(int fd, uint16_t reg)
{
	write_pointer_reg(fd, Addr_config_reg);
	int ret = write(fd, &reg, sizeof(reg));
	if (ret < 0)
		perror("Write to config reg failed");

}
 
uint8_t read_config_reg(int fd)
{
	uint16_t config_value;
	uint8_t buff[1] = {0};
	
	write_pointer_reg(fd, Addr_config_reg);
	int ret =  read(fd,&buff,sizeof(buff));
	if (ret < 0)
		perror("Read config reg failed");
	
	//shift?  config_value = 
	return config_value;
}

int temp_init()
{
	char i2c_name[20] = "/dev/i2c-2";
	int file;
	file = open(i2c_name, O_RDWR);
	if (file < 0) 
	{
		perror("Error in file opening");
		exit(-1);
	}
	int addr = 0x48;

	if (ioctl(file, I2C_SLAVE, addr) < 0) 
	{
		perror("Can't access the bus");
		exit(-1);
	}
	return file;	
}

//void main()
//{
	/*int fd;
	float value;
	fd = temp_init();
	value = read_temp_reg(fd,Celsius);
	printf("%f", value);*/

	/*mqd_t logger;   // queue descriptors   
    	struct mq_attr attr;
	
	float* buff;
	char * finalptr;
	
    	//attr.mq_flags = 0;
    	attr.mq_maxmsg = MAX_MESSAGES;
    	attr.mq_msgsize = sizeof(finalptr);
    	//attr.mq_curmsgs = 0;
	
	logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
	if (logger < 0) 
        printf("ERROR opening message queue\n");
	char a = 'b';
	char* ptr = &a;
	buff = &value;
	//finalptr = (char *)&value;
	if (mq_send (logger, ptr, sizeof(a), 0) == -1)
		printf("ERROR mq_send\n");
	else printf("Temp task message sent-> %c\n",*ptr);
	
	//mq_unlink(SERVER_QUEUE_NAME);*/
//}
/*
@file - ligh_task.h
@brief - Header file of light_task.c which includes all the functions for writing and reading various APDS-9301 registers
@author - Nikhil Divekar & Vipraja Patil
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <math.h>

#define slave_address 	0x39
#define command_start 	0x80

#define control_reg 	0x00
#define timing_reg 	0x01
#define th_low_low 	0x02
#define th_low_high 	0x03
#define th_high_low 	0x04
#define th_high_high 	0x05
#define interrupt_reg	0x06
#define id_reg		0x0A
#define data0_low_reg	0x0C
#define data0_high_reg	0x0D
#define data1_low_reg	0x0E
#define data1_high_reg	0x0F

#define control_value 	0x03

#define i2c_name	"/dev/i2c-2"
#define file_name	"my_file"

/*
@brief - 	light_sensor_setup
			Initializing APDS-9301 sensor 
@param -	
@return - 	file descriptor
*/
uint8_t light_sensor_setup();

/*
@brief - 	write_command_register
			Write to command register
@param -	file descriptor
@return - 	value written to the register 
*/
uint8_t write_command_register(int fd);

/*
@brief - 	read_control_reg
			Read value from Control register
@param -	file descriptor
@return - 	value read from the register 
*/
uint8_t read_control_reg(int fd);

/*
@brief - 	write_control_register
			Write to control register
@param -	file descriptor
			value to be written in the register
@return - 	value written to the register 
*/
uint8_t write_control_reg(int fd, uint8_t write_val);

/*
@brief - 	read_timing_reg
			Read value from Timing register
@param -	file descriptor
@return - 	value read from the register 
*/
uint8_t read_timing_reg(int fd);

/*
@brief - 	write_timing_register
			Write to Timing register
@param -	file descriptor
			value to be written in the register
@return - 	value written to the register 
*/
uint8_t write_timing_reg(int fd, uint8_t write_val);

/*
@brief - 	read_int_control_reg
			Read value from Interrupt Control register
@param -	file descriptor
@return - 	value read from the register 
*/
uint8_t write_int_control_reg(int fd, uint8_t write_val);

/*
@brief - 	write_int_control_register
			Write to Interrupt control register
@param -	file descriptor
			value to be written in the register
@return - 	value written to the register 
*/
uint8_t read_int_control_reg(int fd);

/*
@brief - 	read_id_reg
			Read value from Identification register
@param -	file descriptor
@return - 	value read from the register 
*/
uint8_t read_id_reg(int fd);

/*
@brief - 	write_id_register
			Write to Identification register
@param -	file descriptor
			value to be written in the register
@return - 	value written to the register 
*/
uint8_t write_id_reg(int fd, uint8_t write_val);

/*
@brief - 	read_interrupt_threshold_reg
			Read value from Interrupt threshold register
@param -	file descriptor
@return - 	value read from the register 
*/
uint8_t * read_interrupt_threshold_reg(int fd, uint8_t * read_buffer);

/*
@brief - 	write_interrupt_threshold_register
			Write to Interrupt threshold register
@param -	file descriptor
			value to be written in the register
@return - 	value written to the register 
*/
uint8_t * write_interrupt_threshold_reg(int fd, uint8_t * write_buffer);

/*
@brief - 	read_data0_reg
			Read value from Data0 register
@param -	file descriptor
@return - 	value read from the register 
*/
uint16_t read_data0_reg(int fd);

/*
@brief - 	read_data1_reg
			Read value from Data0 register
@param -	file descriptor
@return - 	value read from the register 
*/
uint16_t read_data1_reg(int fd);

/*
@brief - 	get_lux_value
			Get lux values 
@param -	file descriptor
@return - 	lux value 
*/
float get_lux_value(int fd);
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>

void socket_server();
#include <stdio.h>
#include <stdlib.h>

void userLED(int LED_number, int on_off);
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <fcntl.h> 
#include <sys/stat.h>
#include <mqueue.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <stdbool.h>
//#include "logger_task.h"

bool startup();
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <fcntl.h> 
#include <sys/stat.h>
#include <mqueue.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>

#define SERVER_QUEUE_NAME   "/my_msg_queue_server"
#define QUEUE_PERMISSIONS 0666
#define MAX_MESSAGES 10
#define MAX_MSG_SIZE 256
#define MSG_BUFFER_SIZE MAX_MSG_SIZE + 10

typedef struct {
	float tempval;
	float t;
	int log_source_id;
}temp_data;

/*typedef enum
{
	Info,
	Data,
	Error
}level_id;*/

typedef enum
{
    Light = 0,
    Temp = 1,
    Dead = 2,
    Logger = 3,
    Socket = 4
}command_enum;

typedef enum
{
    Day = 0,
    Night = 1
}day_or_night;

typedef enum
{
    Light_task = 0,
    Temp_task = 1,
    Main_task = 2,
    Socket_task = 3
}logger_source_id;

void loggerFN();
#include <stdio.h>
#include <stdlib.h>

void userLED(int LED_number, char on_off);
#include "socket_task.h"
#include "logger_task.h"
#include "temp_task.h"
#include "light_task.h"

void socket_server()
{
	int sock;
	struct sockaddr_in server, client;
	int mysock;
	char buff[1024];
	int rval;

	//create socket
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock < 0)
	{
		perror("Failed to create a socket");
		exit(1);
	}
	
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons(6000);
	
	//bind
	if(bind(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
	{
		perror("Didn't bind");
		exit(1);
	}

	//Listen
	if(listen(sock, 5) < 0)
	{
		perror("Listening error");
		exit(1);
	}

	//Accept
	while(1)
	{
	mysock = accept(sock, (struct sockaddr *)0, 0);
	if(mysock == -1)
	{
		perror("Accept failed");
		exit(1);
	}
	int incoming;
	int data_in = read(mysock,&incoming,sizeof(incoming));
     	mqd_t logger;   // queue descriptors   
   	struct mq_attr attr;

	attr.mq_maxmsg = MAX_MESSAGES;
    	attr.mq_msgsize = sizeof(temp_data);
	temp_data temp;

	logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
		if (logger < 0) 
        		printf("ERROR opening message queue\n");
	
		temp.tempval = 0;
		temp.t = 7;
		temp.log_source_id = Socket_task;
		char* buffptr = (char*)(&temp);
	
		if (mq_send (logger, buffptr, sizeof(temp_data), 0) == -1)
		printf("ERROR mq_send\n");

	logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
	if (logger < 0) 
        printf("ERROR opening message queue\n");
	
	
	if (data_in < 0)
	{ 
		perror("Error reading");
		exit(1);
	}
        printf("Message: %d \n", incoming);

	if(incoming == 4)
	{
		//call get_light_task
		printf("Light task called \n");
		int fd = light_sensor_setup();
		float lux = get_lux_value(fd);
		printf("LUX: %f", lux);
		temp_data temp;

		int data_out = send(mysock, (void*)&lux, sizeof(lux), 0);
		if (data_out < 0)
		{
			perror("Error writing");
			exit(1);
		}
		else
			printf("Data sent back");
	}
	else if(incoming == 1)
	{
		//call get temp task
		printf("temp task called \n");
		int fd = temp_init();
		float value = read_temp_reg(fd,Celsius);
		printf("TEMP: %f", value);

		int data_out = send(mysock, (void*)&value, sizeof(value), 0);
		if (data_out < 0)
		{
			perror("Error writing");
			exit(1);
		}
		printf("Data sent back");
	}
	else if(incoming == 2)
	{
		//call get temp task
		printf("temp task called \n");
		int fd = temp_init();
		float value = read_temp_reg(fd,Kelvin);
		printf("TEMP: %f", value);

		int data_out = send(mysock, (void*)&value, sizeof(value), 0);
		if (data_out < 0)
		{
			perror("Error writing");
			exit(1);
		}
		printf("Data sent back");
	}
	else if(incoming == 3)
	{
		//call get temp task
		printf("temp task called \n");
		int fd = temp_init();
		float value = read_temp_reg(fd,Fahrenheit);
		printf("TEMP: %f", value);

		int data_out = send(mysock, (void*)&value, sizeof(value), 0);
		if (data_out < 0)
		{
			perror("Error writing");
			exit(1);
		}
		printf("Data sent back");
	}
	if(incoming == 5)
	{
		//call get_light_task
		printf("Light task called \n");
		int fd = light_sensor_setup();
		float lux = get_lux_value(fd);
		int DN = is_it_day_or_night(lux);
		//printf("LUX: %f", lux);
		temp_data temp;

		int data_out = send(mysock, (void*)&DN, sizeof(DN), 0);
		if (data_out < 0)
		{
			perror("Error writing");
			exit(1);
		}
		else
			printf("Data sent back");
	}
	}
	exit(1);
}
#include "led.h"

void userLED(int LED_number, char on_off)
{
	FILE* fd;
	if (LED_number > 3 && LED_number < 0)
	{
		printf("Invalid led number");
		exit(-1);
	}

	if (on_off != 0 | on_off != 1)
	{
		printf("Input should be either 0 or 1");
	}
	switch(LED_number)
	{
		case 1:
			fd = fopen("/sys/devices/platform/leds/leds/beaglebone:green:usr0/brightness", "w");
			fwrite(on_off, 1, 1, fd);
			break;
		case 2:
			fd = fopen("/sys/devices/platform/leds/leds/beaglebone:green:usr1/brightness", "w");
			fwrite(on_off, 1, 1, fd);
			break;
		case 3:
			fd = fopen("/sys/devices/platform/leds/leds/beaglebone:green:usr2/brightness", "w");
			fwrite(on_off, 1, 1, fd);
			break;
	}
	fclose(fd);
}

void main()
{
	userLED(1,"1");
}
#include "logger_task.h"

pthread_mutex_t pmutex;

void loggerFN()
{  
    	struct mq_attr attr;
	mqd_t logger;   // queue descriptors 
	//FILE *fptr = fopen("projectlog.log","w");	

	while(1)
	{
	FILE *fptr = fopen("projectlog.log","a");

	time_t currenttime;
	time(&currenttime);
	char *timeStr = ctime(&currenttime);
	fprintf(fptr,"Time: %s",timeStr);
	
	//message *ptr;
    	temp_data temp;
	 char buff[sizeof(temp_data)] = {0};

    	attr.mq_maxmsg = MAX_MESSAGES;
   	attr.mq_msgsize = sizeof(temp_data);
    
	pthread_mutex_lock(&pmutex);
	logger = mq_open (SERVER_QUEUE_NAME, O_RDWR | O_CREAT, QUEUE_PERMISSIONS, &attr);
	if (logger < 0) 
        printf("ERROR opening message queue\n");
	
	if (mq_receive (logger, buff, sizeof(temp_data), NULL) < 0)
			printf("ERROR mq_receive\n");
	//else printf ("Temp task message received.\n");
	pthread_mutex_unlock(&pmutex);
	
	temp_data* ptr;
	ptr = (temp_data*)(buff);
	char message[1024];
	if(ptr -> log_source_id == 1)
		strcpy(message, "Temperature recorded");
	if(ptr -> log_source_id == 0)
		strcpy(message, "Light lux recorded");
	if(ptr -> log_source_id == 3)
		strcpy(message, "External service requested data");
	if(ptr -> log_source_id == 2 && ptr -> t == 0)
		strcpy(message, "Initializing main task");
	if(ptr -> log_source_id == 2 && ptr -> t == 1)
		strcpy(message, "Light thread created");
	if(ptr -> log_source_id == 2 && ptr -> t == 2)
		strcpy(message, "Temp thread created");
	if(ptr -> log_source_id == 2 && ptr -> t == 3)
		strcpy(message, "Logger thread created");
	if(ptr -> log_source_id == 2 && ptr -> t == 5)
		strcpy(message, "Socket thread created");
	if(ptr -> log_source_id == 2 && ptr -> t == 4)
		strcpy(message, "Terminating process");
	
    	fprintf(fptr,"Data: %f, Message: %s, Log Source: %d\n", ptr->tempval, message, ptr->log_source_id);
	//printf("In logger received: %f", ptr -> tempval); 

	fclose(fptr);

	//mq_unlink(SERVER_QUEUE_NAME);
	}
}
/*
@file - light_task.c
@brief - Includes all the functions for writing and reading various APDS-9301 registers
@author - Nikhil Divekar & Vipraja Patil
*/

// light task
#include "light_task.h"
#include "logger_task.h"

uint8_t light_sensor_setup()
{
	char filename[20] = "/dev/i2c-2";
	int file;
	file = open(filename, O_RDWR);
	if (file < 0) 
	{
		perror("Error in file opening");
		exit(-1);
	}
	int slave_addr = 0x39;

	if (ioctl(file, I2C_SLAVE, slave_addr) < 0) 
	{
		perror("Ioctl error");
		exit(-1);
	}
	return file;	
}

uint8_t write_command_register(int fd)
{
	uint8_t data;
	data = command_start;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
}
	
uint8_t read_control_reg(int fd)
{
	uint8_t data;
	data = command_start | control_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	return data;
}

uint8_t write_control_reg(int fd, uint8_t write_val)
{
	uint8_t data;
	data = command_start | control_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = write_val;
	if(write(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	return data;
}

uint8_t read_timing_reg(int fd)
{
	uint8_t data;
	data = command_start | timing_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	return data;
}

uint8_t write_timing_reg(int fd, uint8_t write_val)
{
	uint8_t data;
	data = command_start | timing_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = write_val;
	if(write(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	return data;
}

uint8_t write_int_control_reg(int fd, uint8_t write_val)
{
	uint8_t data;
	data = command_start | interrupt_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = write_val;
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	return data;
}

uint8_t read_id_reg(int fd)
{
	uint8_t data;
	data = command_start | id_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	return data;
}

uint8_t * read_interrupt_threshold_reg(int fd, uint8_t * read_buffer)
{
	uint8_t data;
	data = command_start | th_low_low;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	read_buffer[0] = data;

	data = command_start | th_low_high;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	read_buffer[1] = data;
	
	data = command_start | th_high_low;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	read_buffer[2] = data;

	data = command_start | th_high_high;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	read_buffer[3] = data;

	return read_buffer;
}

uint8_t * write_interrupt_threshold_reg(int fd, uint8_t * write_buffer)
{
	uint8_t data;
	data = command_start | th_low_low;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = write_buffer[0];
	if(write(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}

	data = command_start | th_low_high;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = write_buffer[1];
	if(write(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	
	data = command_start | th_high_low;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = write_buffer[2];
	if(write(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}

	data = command_start | th_high_high;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = write_buffer[3];
	if(write(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	return write_buffer;
}

uint16_t read_data0_reg(int fd)
{
	uint16_t data_lsb, data_msb, final_data0;
	uint8_t addr;
	addr = command_start | data0_low_reg;
	if(write(fd, &addr, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data_lsb, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}

	addr = command_start | data0_high_reg;
	if(write(fd, &addr, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data_msb, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	data_msb = data_msb << 8;
	
	final_data0 = data_msb | data_lsb;

	return final_data0;
}

uint16_t read_data1_reg(int fd)
{
	uint16_t data_lsb, data_msb, final_data1;
	uint8_t addr;
	addr = command_start | data1_low_reg;
	if(write(fd, &addr, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data_lsb, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}

	addr = command_start | data1_high_reg;
	if(write(fd, &addr, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data_msb, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}
	data_msb = data_msb << 8;
	
	final_data1 = data_msb | data_lsb;

	return final_data1;
}

float get_lux_value(int fd)
{
	float lux_value = 0;
	uint8_t check;
	check = light_sensor_setup();
	if(check < 0)
	{
		perror("Sensor not set up");
	}
	write_control_reg(fd, 0x03);
	write_timing_reg(fd, 0x12);
	usleep(500);
	
	float data0_op, data1_op;
	data0_op = (float)read_data0_reg(fd);
	data1_op = (float)read_data1_reg(fd);

	float adc_count;
	
	if(data0_op == 0 || data1_op == 0)
	{
		adc_count = 0;
	}
	adc_count = data1_op/data0_op;
	
	if(0 < adc_count < 0.50)
	{
		lux_value = (0.0304 * data0_op) - (0.062 * data0_op * powf(adc_count, 1.4));
	}
	else if(0.50 < adc_count < 0.61)
	{
		lux_value = (0.0224 * data0_op) - (0.031 * data1_op);
	}
	else if(0.61 < adc_count < 0.80)
	{
		lux_value = (0.0128 * data0_op) - (0.0153 * data1_op);
	}
	else if(0.80 < adc_count < 1.30)
	{
		lux_value = (0.00146 * data0_op) - (0.00112 * data1_op);
	}
	else
	{
		lux_value = 0;
	}
	return lux_value;
}

int is_it_day_or_night()
{
	int fd = light_sensor_setup();
	float lux = get_lux_value(fd);
	if(lux < 100)
	{
		return Night;
	}
	else
	{
		return Day;
	}
}


/*void main()
{
	//float data;
	int fd = light_sensor_setup();
	//write_control_reg(fd, 0x1);
	/*uint8_t data;
	data = command_start | control_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	data = 5;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}*/	
	//data = read_control_reg(fd);

	//uint8_t data;
	/*data = command_start | control_reg;
	if(write(fd, &data, 1) < 0)
	{
		perror("Write error");
		exit(-1);
	}
	if(read(fd, &data, 1) < 0)
	{
		perror("Read error");
		exit(-1);
	}*/
	//get_lux_value(fd);
	/*float lux;
	lux = get_lux_value(fd);
	printf("%f", lux);
	/*uint8_t value = 4;
	value = write_timing_reg(fd, value);
	value = read_timing_reg(fd);
	printf("%d", value);*/
	
//}
	
	



#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>

typedef enum
{
    Light = 0,
    Temp = 1
}command_enum;

void main(int argc, char *argv[])
{
	//while(1)
	{
	int sock;
	struct sockaddr_in server;
	char buff[1024];
	struct hostent *hp;
	int command;
	
	printf("List of commands available:\n");
	printf("1. Get temp output in Celsius\n");
	printf("2. Get temp output in Kelvin\n");
	printf("3. Get temp output in Fahrenheit\n");
	printf("4. Get lumen output\n");
	printf("5. Is it day or night?\n");
	printf("Enter approprate command number\n");

	scanf("%d", &command);
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock < 0)
	{
		perror("socket failed");
		exit(1);
	}
	server.sin_family = AF_INET;
	hp = gethostbyname(argv[1]);
	if(hp == 0)
	{
		perror("gethost failed");
		exit(1);
	}
	memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
	server.sin_port = htons(6000);
	
	if(connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
	{
		perror("connection failes");
		exit(1);
	}

	//int command = Light;
	
	
	if(send(sock, (void*)&command, sizeof(command), 0) < 0)
	{
		perror("Send failed");
		exit(1);
	}
	printf("Sent : %d \n", command);
	//sleep(1);

	//int mysock;
	//mysock = accept(sock, (struct sockaddr *)0, 0);

	float incoming;
	int data_in = read(sock, &incoming, sizeof(incoming));
        if (data_in < 0)
	{	 
        	perror("Read failed");
		exit(1);
	}
	printf("Data got back: %f", incoming);

	//close(sock);
	//exit(1);
	sleep(1);
	}
}
